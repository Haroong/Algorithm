# ✔️ [문제](https://www.acmicpc.net/problem/2891)
2890번을 보면 알겠지만, 상근이는 카약 대회를 개최했다. 그런데, 갑자기 엄청난 강풍이 경기장에 불었고, 일부 카약이 부서졌다. 경기는 5분 안에 시작해야 하는 상황이다.

다행히 일부 팀은 혹시 모를 사태에 대비해서 카약을 하나 더 경기장에 들고 왔다. 카약은 매우 무겁고 운반하기 어렵다. 따라서, 자신의 바로 다음이나 전에 경기하는 팀에게만 카약을 빌려주려고 한다. 즉, 팀 4는 여분의 카약을 3이나 5에게만 빌려줄 수 있다. 또, 카약을 하나 더 가져온 팀의 카약이 손상되었다면, 여분의 카약으로 경기에 출전하게되고, 이 카약은 다른 팀에게 빌려줄 수 없다.

카약이 부서진 팀과 하나 더 가져온 팀이 주어진다. 카약을 적절히 빌렸을 때 출발하지 못하는 팀의 최솟값은 몇 팀인지 구하는 프로그램을 작성하시오.

---
[입력]
첫째 줄에 팀의 수 N, 카약이 손상된 팀의 수 S, 카약을 하나 더 가져온 팀의 수 R이 주어진다. (2 ≤ N ≤ 10, 1 ≤ S, R ≤ N)

둘째 줄에는 카약이 손상된 팀의 번호가 주어진다. 팀 번호는 중복되지 않는다.

셋째 줄에는 카약을 하나 더 가져온 팀의 번호가 주어진다. 팀 번호는 중복되지 않는다.

[출력]
첫째 줄에 출발을 할 수 없는 팀의 최솟값을 출력한다.

# 😎 소스 코드
```python
N, S, R = map(int, input().split())
broken = list(map(int, input().split()))
spare = list(map(int, input().split()))

answer = S

# ascending sort
broken.sort()
spare.sort()

# check if possible to start
for i in range(S):
	if not spare:
		# no more extra kayaks
		break
	for j in range(R):
		# find kayak..
		if broken[i] == spare[j] or broken[i] == spare[j] + 1 or broken[i] == spare[j] - 1:
			answer -= 1
			spare[j] = -1 # used kayak
			break
			
print(answer)

```
# ✊ 문제를 풀고 나서
IndexError 때문에 하루죙일 고민한 문제였다 ㅠㅠ
코드를 맞게 작성한 것 같은데(물론 당연히 내가 틀렸지만) 왜 틀렸을까.. 반례로 뭐가 있을까 운동하면서도 고민했다 ㅋㅋ 그러다가 예시를 하나 생각해내서 실행했는데 반갑게도 IndexError가 뜨는것이다. 옳거니하고 디버깅했다.
>아래의 숫자를 입력해봤는데 에러가 떴다!   
9 5 2  
1 3 7 8 9  
5 9  

디버깅하면서 코드의 문제점을 발견했다. 처음에 내가 작성한 코드는 여유분의 카약이 사용되면 ``spare``리스트에서 제거하도록 했다. 근데 이게 문제점이.. for loop를 R만큼 반복하게 되니까 이미 삭제돼서 없는 인덱스를 접근하게 되니까 에러가 발생한 것이다. 

그래서 문제되는 코드는 지우고 기존의 리스트를 유지하면서 이미 사용한 카약을 표시하는 방법을 생각했다. 바로바로!! 해당 카약에 -1을 부여하는 것이다. 

이 방법으로 코드를 작성하고 제출하니 드디어 **맞았습니다!**가 떴다. 힘겨운 싸움이었다 ㅋㅋ 이제 자러가야지.
